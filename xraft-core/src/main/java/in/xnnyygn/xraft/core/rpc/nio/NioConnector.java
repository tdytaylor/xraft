package in.xnnyygn.xraft.core.rpc.nio;

import com.google.common.base.Preconditions;
import com.google.common.eventbus.EventBus;
import in.xnnyygn.xraft.core.node.NodeEndpoint;
import in.xnnyygn.xraft.core.node.NodeId;
import in.xnnyygn.xraft.core.rpc.Channel;
import in.xnnyygn.xraft.core.rpc.ChannelConnectException;
import in.xnnyygn.xraft.core.rpc.Connector;
import in.xnnyygn.xraft.core.rpc.message.AppendEntriesResult;
import in.xnnyygn.xraft.core.rpc.message.AppendEntriesRpc;
import in.xnnyygn.xraft.core.rpc.message.AppendEntriesRpcMessage;
import in.xnnyygn.xraft.core.rpc.message.InstallSnapshotResult;
import in.xnnyygn.xraft.core.rpc.message.InstallSnapshotRpc;
import in.xnnyygn.xraft.core.rpc.message.InstallSnapshotRpcMessage;
import in.xnnyygn.xraft.core.rpc.message.PreVoteResult;
import in.xnnyygn.xraft.core.rpc.message.PreVoteRpc;
import in.xnnyygn.xraft.core.rpc.message.PreVoteRpcMessage;
import in.xnnyygn.xraft.core.rpc.message.RequestVoteResult;
import in.xnnyygn.xraft.core.rpc.message.RequestVoteRpc;
import in.xnnyygn.xraft.core.rpc.message.RequestVoteRpcMessage;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import java.util.Collection;
import javax.annotation.Nonnull;
import javax.annotation.concurrent.ThreadSafe;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

// TODO add test
@ThreadSafe
public class NioConnector implements Connector {

  private static final Logger logger = LoggerFactory.getLogger(NioConnector.class);
  private final NioEventLoopGroup bossNioEventLoopGroup = new NioEventLoopGroup(1);
  private final NioEventLoopGroup workerNioEventLoopGroup;
  private final boolean workerGroupShared;
  private final EventBus eventBus;
  private final int port;
  private final InboundChannelGroup inboundChannelGroup = new InboundChannelGroup();
  private final OutboundChannelGroup outboundChannelGroup;

  public NioConnector(NodeId selfNodeId, EventBus eventBus, int port) {
    this(new NioEventLoopGroup(), false, selfNodeId, eventBus, port);
  }

  public NioConnector(
      NioEventLoopGroup workerNioEventLoopGroup, NodeId selfNodeId, EventBus eventBus, int port) {
    this(workerNioEventLoopGroup, true, selfNodeId, eventBus, port);
  }

  public NioConnector(
      NioEventLoopGroup workerNioEventLoopGroup,
      boolean workerGroupShared,
      NodeId selfNodeId,
      EventBus eventBus,
      int port) {
    this.workerNioEventLoopGroup = workerNioEventLoopGroup;
    this.workerGroupShared = workerGroupShared;
    this.eventBus = eventBus;
    this.port = port;
    outboundChannelGroup = new OutboundChannelGroup(workerNioEventLoopGroup, eventBus, selfNodeId);
  }

  // should not call more than once
  @Override
  public void initialize() {
    ServerBootstrap serverBootstrap =
        new ServerBootstrap()
            .group(bossNioEventLoopGroup, workerNioEventLoopGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(
                new ChannelInitializer<SocketChannel>() {
                  @Override
                  protected void initChannel(SocketChannel ch) throws Exception {
                    ChannelPipeline pipeline = ch.pipeline();
                    pipeline.addLast(new Decoder());
                    pipeline.addLast(new Encoder());
                    pipeline.addLast(new FromRemoteHandler(eventBus, inboundChannelGroup));
                  }
                });
    logger.debug("node listen on port {}", port);
    try {
      serverBootstrap.bind(port).sync();
    } catch (InterruptedException e) {
      throw new ConnectorException("failed to bind port", e);
    }
  }

  @Override
  public void sendPreVote(
      @Nonnull PreVoteRpc rpc, @Nonnull Collection<NodeEndpoint> destinationEndpoints) {
    Preconditions.checkNotNull(rpc);
    Preconditions.checkNotNull(destinationEndpoints);
    for (NodeEndpoint endpoint : destinationEndpoints) {
      logger.debug("send {} to node {}", rpc, endpoint.getId());
      try {
        getChannel(endpoint).writePreVoteRpc(rpc);
      } catch (Exception e) {
        logException(e);
      }
    }
  }

  @Override
  public void replyPreVote(@Nonnull PreVoteResult result, @Nonnull PreVoteRpcMessage rpcMessage) {
    Preconditions.checkNotNull(result);
    Preconditions.checkNotNull(rpcMessage);
    logger.debug("reply {} to node {}", result, rpcMessage.getSourceNodeId());
    try {
      rpcMessage.getChannel().writePreVoteResult(result);
    } catch (Exception e) {
      logException(e);
    }
  }

  @Override
  public void sendRequestVote(
      @Nonnull RequestVoteRpc rpc, @Nonnull Collection<NodeEndpoint> destinationEndpoints) {
    Preconditions.checkNotNull(rpc);
    Preconditions.checkNotNull(destinationEndpoints);
    for (NodeEndpoint endpoint : destinationEndpoints) {
      logger.debug("send {} to node {}", rpc, endpoint.getId());
      try {
        getChannel(endpoint).writeRequestVoteRpc(rpc);
      } catch (Exception e) {
        logException(e);
      }
    }
  }

  private void logException(Exception e) {
    if (e instanceof ChannelConnectException) {
      logger.warn(e.getMessage());
    } else {
      logger.warn("failed to process channel", e);
    }
  }

  @Override
  public void replyRequestVote(
      @Nonnull RequestVoteResult result, @Nonnull RequestVoteRpcMessage rpcMessage) {
    Preconditions.checkNotNull(result);
    Preconditions.checkNotNull(rpcMessage);
    logger.debug("reply {} to node {}", result, rpcMessage.getSourceNodeId());
    try {
      rpcMessage.getChannel().writeRequestVoteResult(result);
    } catch (Exception e) {
      logException(e);
    }
  }

  @Override
  public void sendAppendEntries(
      @Nonnull AppendEntriesRpc rpc, @Nonnull NodeEndpoint destinationEndpoint) {
    Preconditions.checkNotNull(rpc);
    Preconditions.checkNotNull(destinationEndpoint);
    logger.debug("send {} to node {}", rpc, destinationEndpoint.getId());
    try {
      getChannel(destinationEndpoint).writeAppendEntriesRpc(rpc);
    } catch (Exception e) {
      logException(e);
    }
  }

  @Override
  public void replyAppendEntries(
      @Nonnull AppendEntriesResult result, @Nonnull AppendEntriesRpcMessage rpcMessage) {
    Preconditions.checkNotNull(result);
    Preconditions.checkNotNull(rpcMessage);
    logger.debug("reply {} to node {}", result, rpcMessage.getSourceNodeId());
    try {
      rpcMessage.getChannel().writeAppendEntriesResult(result);
    } catch (Exception e) {
      logException(e);
    }
  }

  @Override
  public void sendInstallSnapshot(
      @Nonnull InstallSnapshotRpc rpc, @Nonnull NodeEndpoint destinationEndpoint) {
    Preconditions.checkNotNull(rpc);
    Preconditions.checkNotNull(destinationEndpoint);
    logger.debug("send {} to node {}", rpc, destinationEndpoint.getId());
    try {
      getChannel(destinationEndpoint).writeInstallSnapshotRpc(rpc);
    } catch (Exception e) {
      logException(e);
    }
  }

  @Override
  public void replyInstallSnapshot(
      @Nonnull InstallSnapshotResult result, @Nonnull InstallSnapshotRpcMessage rpcMessage) {
    Preconditions.checkNotNull(result);
    Preconditions.checkNotNull(rpcMessage);
    logger.debug("reply {} to node {}", result, rpcMessage.getSourceNodeId());
    try {
      rpcMessage.getChannel().writeInstallSnapshotResult(result);
    } catch (Exception e) {
      logException(e);
    }
  }

  @Override
  public void resetChannels() {
    inboundChannelGroup.closeAll();
  }

  private Channel getChannel(NodeEndpoint endpoint) {
    return outboundChannelGroup.getOrConnect(endpoint.getId(), endpoint.getAddress());
  }

  @Override
  public void close() {
    logger.debug("close connector");
    inboundChannelGroup.closeAll();
    outboundChannelGroup.closeAll();
    bossNioEventLoopGroup.shutdownGracefully();
    if (!workerGroupShared) {
      workerNioEventLoopGroup.shutdownGracefully();
    }
  }
}
